begin 
	- set bpix/fpix sectors, portcard addresses, fpix/bpix dcdcs, & ccu ports
execute 
	- print out above info
	- debugging
		-fill set<pos::PixelModuleNames> modulesToLoop with theDetectorConfiguration modules
		-get LV status for all these modules and print out nodeLVstatusMap_ items
end calibration 
	-does nothing

getLVstatusForModules 
	-takes in list of modules
	-loop over modules and try and see if theLowVoltageMap dpName is empty, if so add the name to nodesToBeQuerried
	-for all nodesToBeQuerried
		- create a string command (.getState) and then add this to list_return_Node
		- add a PixelDCSPVSSDpe using the complete_note (that is, the command with .getState) to dpes
		-create a pair of return_Pair = note_complete and return_string = "None" ?? and add this pair to nodeLVstatusMap
	- try returndpes = pvssCommander_->getDpeValues(dpes), and if this doesn't work, raise an error saying there was a failure to get a status from the PSX server, make the return string "STATE_MIXED", set the return pair to have the command and this state, and then return false
	-loop through all the returndpes, create a msg_status with status
		-if the return_string is None, set it to dpe->getValue()
		-else if the return_string is not already set to dpe->getValue(), set return_string to STATE_MIXED
		-set the return_Node as dpe->GetName() , return_Pair.first = return_Node, return_Pair.second = return_string
		-add the return pair to nodeLVstatusMap
getDCDCstatusForModules 
	-pg = power group
	-takes in the moduleList
	-for each of the modules, set dcdc power group name and dcdc name= dcdcpg.first, and power group name = dcdcpgname.second
		-create pair of modulename and dcdc name, add it to modDCDCstatusMap_
	-return modDCDCstatusMap_ at the end of the day

setOnpower
	-takes in a set of strings called compList = ?
	-create a list of PixelDCSPVSSDpe called set_dpes
	-for all strings in compList, add an PixelDCSPVSSDpe((string), "1") entry to set_dpes
	-if pvssCOmmander_ is not empty, for all objets in nodeLVstatusMap_
		-if "ON" is found in the second string of an entry, try and set status to off by doing pvssCommander_->setDpeValue(it->first, "LV_OFF");
			-if this doesn't work, raise an exception saying that the status was failed to be printed
		-if status is not "ON", print status and leave as it is
	-disable DCDCs here?
	-try and set LV status to "LV_ON" with pvssCommander_->setDpeValue(it->first, "LV_ON");
		-if this doesn't work, raise exception 
	-or raise DCDCs here?
checkKillOpenProcess
	-takes in a strng called systemStr
	-get port for a ccu from port = ccu_ports_[systemLower]
	-connect two nodes AF_INET and SOCK_STREAM? What is SOCK_STREAM?
	-struct sockaddr_in address -> no idea what this is doing


	-checks to see if process is still running
	-return bool port_free at end of the day 
exec 
	- given a command, executes a given command and tells you if it works or not
sendToCcu
	-takes in a systemStr, and a string ns_command
	-if checkKillOpenProcess(systemStr) is false, return a pair saying "Exit due to already open process"
	-if systemLower has instances of bpix_, delete them
	-set opstoolpath using getenv("BPIXELTOOLS") 
	-what does this do? - std::string opstoolspath(opstoolspathTemp);
join 
	-takes in a vector<string> and a string separator and create a single string out of the vector elements separated by the separator
enableDisableDcdcs
	-takes in a systemStr, action string, vector<std:;string> portcards, vector<std::string> layer = {},, dis, string for dcdc_numbers, bool for sequential, and bool for fast
	-loop over portcards
		-loop over portcard addresses
			-if portcard addresses.first equals the portcard address, set _ccu, _ring and insert an element for these in ccus, rings, and add portcard address to names 
	-loop over rings
		-start adding to string this_command with ring and ccu info
		-if action is neither "on" or "off", add fout_command, ns_stdout, and ns_stderr to ns_inOutErr and return this vector
		-if dcdc_number is not empty, add to this command with "power" + dcdc name + action ("on" or "off") + "sleep"
		-otherwise, look to see for instances of "bpix" and "prt1"||"prt2"||(!layer.empty())||"d1"||"d2"||"d3"||(!disc.empty) and add to this_command 
		-if this_command is found inside ns_command, then insert an instance 
		-if ns_command is empty, insert error things into ns_inOutErr and then return it 
		-join together all of ns_command using join with foutSeparator
		-set setOutErr using sendToCcu(systemStr, fout_command)
			-ns_stdout = stdOutErr.first
			-ns_stderr = stdOutErr.second
		-fill ns_inOutErr with all three of these, and then return this vector
writePiagRegEnable

enableDcdcs

disableDcdcs



1.need to loop over modules
2. can't turn on module by module, more than one can be part of the same power group, need to do the mapping first 
need module -> power group map
need module -> dcdc
1 dcdc can be connected to more than one dcdc and power group, 
test setup doesn't have way to check whether LV is on or off, just assume all are on or all are off
3. 